关于binary index tree (fenwick tree) (aka 树状数组)
关键是利用了二进制的位运算的巧妙, 常见于编程竞赛(易于实现,跑得快)

考虑线段树(segment tree) 的使用范围(需要统计一个数组某段大小,同时要不时更新):
暴力算法就是所有数叠加,并且那么每次查询O(1),更新时O(n).

线段树和树状数组则是查询和更新都是O(logn)

树状数组的解释:
每个偶数都有其"负责" 的范围: 如 8 1000 那么他就负责 0001~1000 这八个数
又如12 1100,它负责 1001~1100 四个数
那么每次更新时, 就从lowest bit开始查找"父节点"
例如对于9 1001 它分别由10 1010/ 12 1100 负责. 简单的 i+=lowest bit 即可不断"向上"更新 "负责" 它的节点.

对于查询时,例如对于查询1-15的和 15 1111 则可不断减小最低位的数(直至0) 来求和
例如15 = T[1111] + T[1110] +T[1100]+T[1000],恰巧与上述"负责" 制度 1-15求和相符合.
