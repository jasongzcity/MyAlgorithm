要做出比较好的答案有两个点: 
1. 用二分法找到pivot. 巧妙的利用二分查找找到了pivot(可以看另写的代码,找largest显然要麻烦不少)
这里引出一个诀窍:
对于条件是lo<hi的循环 不能有 lo = mid 的语句, 会构成死循环.
对于条件是lo<hi-1的循环,不要引用array[hi],一般这类循环中hi是not inclusive的
但对于这种循环. lo可以指向 mid

2. 用(mid+pivot)%n 巧妙的找到realmid. 
可以将翻转到数组前段的内容想象成是跟在数组末端的,如图: [7,8,9,10,11,12,13,14,15,16,0,1,2]{,7,8,9,10,11,12,13,14,15,16}
{}中的数字内容可以认为是假想的, 通过+pivot(10),可以认为是加上了某个偏移量.才是后面这个有序数组的下标.
而需要访问时,再%n,"翻转"回来.

另一更容易理解方法见源码,和#81同样的思想. 注意考虑边界情况的处理.