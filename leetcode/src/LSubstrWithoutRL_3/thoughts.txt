1.乍一看有点像largest subarray问题.
2. 思路: 用一个hashmap来暂存"当前"子字符串包含的字符和他们所在的位置.不断前挪来查找最大子字符串.
     我的代码实际上不是最优的. 特别地. 更好地方法应该是保持两个指针, 前指针扫描时将<Char,position> 对存入map
     但不同的是,当在map中查找到相同的char时,不回头在map中删东西,只是更新,同时判断后指针是否向前.每次迭代都更新
     最大长度.
     
     这题其实相当巧妙: 通过判断指针是否向前,可知,目前在map中遇到的字母有没有包含在当前子字符串中.